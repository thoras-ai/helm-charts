---
thorasVersion: "4.57.0"
cluster:
  name: ""

imageCredentials:
  registry: "us-east4-docker.pkg.dev/thoras-registry/platform"
  username: "_json_key_base64"

  # Set the license key directly as a variable (or alternatively
  # use imageCredentials.secretRef to reference an existing secret
  password: ""

  # Reference a pre-existing secret in the Thoras namespace
  secretRef: ""

resourceQuota:
  enabled: false
  pods: 200
  cronjobs: 200
  jobs: 200

imagePullPolicy: "IfNotPresent"

logLevel: info

featureFlags:
  enableSkipScalingOnInsufficientData: true

# Cost refresh batching configuration (shared by thorasApiServerV2 and thorasWorker)
costRefreshBatching:
  enabled: true
  batchSize: 200
  maxConcurrency: 5

# Enable Slack errors
slackErrorsEnabled: false

# Set Slack notification Webhook URL directly (or alternatively use
# use slackWebhookUrlSecretRef to reference an existing secret
slackWebhookUrl: ""

# If you'd like to reference an existing secret, use these two values
# to indicate the secret name and data key
slackWebhookUrlSecretRefName: ""
slackWebhookUrlSecretRefKey: ""

rbac:
  namespaces: []

thorasOperator:
  # Operator is a singleton -- don't change this :)
  replicas: 1
  serviceAccount:
    name: thoras-operator
  podAnnotations: {}
  labels: {}
  limits:
    memory: 2Gi
  requests:
    cpu: 100m
    memory: 128Mi
  prometheus:
    enabled: true
    port: 9101

metricsCollector:
  persistence:
    enabled: false
    volumeName: ""
    storageClassName: "efs-sc-thoras"
    accessMode: "ReadWriteOnce"
    createEFSStorageClass:
      fileSystemId: ""
    pvcStorageRequestSize: "3Gi"
  podAnnotations: {}
  labels: {}
  serviceAccount:
    name: thoras-collector
  init:
    imageTag: "3.23.0"
    limits:
      memory: "8192Mi"
    requests:
      cpu: "16m"
      memory: "32Mi"
  timescale:
    image: "timescaledb"
    imageTag: "2.24.0-pg16"
    extensionVersion: "2.24.0"
    name: timescale
    containerPort: 5432
    limits:
      memory: "16384Mi"
    requests:
      cpu: "1024m"
      memory: "3072Mi"
    config:
      enabled: false
      content: |
  blobService:
    logLevel: "info"
    pprof:
      enabled: false
    containerPort: 8080
    port: 80
    limits:
      memory: "8192Mi"
    requests:
      cpu: "16m"
      memory: "128Mi"
  additionalPvSecurityContext: {}

thorasApiServerV2:
  rbac:
    create: true
  serviceAccount:
    name: thoras-api
  containerPort: 8080
  podAnnotations: {}
  labels: {}
  replicas: 1
  limits:
    memory: 2Gi
  requests:
    cpu: 128m
    memory: 256Mi
  port: 80
  logLevel: "info"
  additionalPvSecurityContext: {}
  prometheus:
    enabled: true
  restartWorkloadOnCpu: false
  enableForecastAffinity: true
  pprof:
    enabled: false
  enableViewCacheQueryLiveJoin: true

thorasWorker:
  enabled: true
  serviceAccount:
    name: thoras-worker
  podAnnotations: {}
  labels: {}
  replicas: 1
  limits:
    memory: 2Gi
  requests:
    cpu: 128m
    memory: 256Mi
  logLevel: "info"
  prometheus:
    enabled: true
    port: 9102
  enableSnapshotChunkAutoSizing: true
  enableDirectForecastQueueing: true
  # Cost will not work in the dashboard if this is disabled. Used for debugging purposes.
  enableAstViewCacheRefreshWorker: true
  enableAstViewCacheStateReconcilerWorker: true
  enableMetricIntegrityWorker: false
  enableActiveSuggestionWorker: false
  enableUnifiedAstUtilizationMonitor: false

thorasDashboard:
  enabled: true
  serviceAccount:
    name: thoras-dashboard
    create: true
  rbac:
    create: true
  podAnnotations: {}
  labels: {}
  containerPort: 5173
  nginxContainerPort: 80
  nginx:
    imageTag: "1.29.4-alpine3.23-slim"
  limits:
    memory: 2Gi
  requests:
    cpu: 100m
    memory: 128Mi
  port: 80
  replicas: 1
  service:
    type: ClusterIP
    annotations: {}
  ingress:
    enabled: false
    ingressClassName: "nginx"
    annotations: {}
    hosts:
      - host: thoras.local
        paths:
          - path: /
            pathType: Prefix
    tls: []
  gatewayAPI:
    enabled: false
    annotations: {}
    parentRefs:
      - name: gateway
        namespace: default
    hostnames:
      - thoras.local
    path: /
    pathType: PathPrefix
  extras:
    show_savings: true
    cost_analysis: true
    cost_simulator: true
    rolling_savings: true
    cost_breakdown_v2: true

thorasMonitor:
  enabled: false
  serviceAccount:
    name: thoras-monitor
  unittesting: false
  limits:
    memory: "8192Mi"
  requests:
    cpu: "16m"
    memory: "64Mi"
  podAnnotations: {}
  labels: {}
  config: |

thorasForecast:
  serviceAccount:
    name: thoras-forecast-worker
  skipCache: false
  ignoreNewPods: false
  enableDecoupledTraining: false
  trainingJitterMinutes: 0
  requests:
    cpu: "256m"
    memory: "256Mi"
  limits:
    memory: "8Gi"
    cpu: "4"
  worker:
    replicas: 1
    pollingInterval: 15
    podAnnotations: {}
    retrainSteadyStateHours: ""
    retrainOverrideHours: ""
    maxTimeseriesMetricCacheSizeMb: 1000
    labels: {}
    limits:
      memory: 2Gi
      cpu: 2
    requests:
      cpu: 1
      memory: 256Mi
    forecastTimeout: 600
  prometheus:
    enabled: true
    port: 9101

thorasAgent:
  enabled: false
  serviceAccount:
    name: thoras-agent
  frequency: 15
  containerPort: 9101
  podAnnotations: {}
  labels: {}

thorasReasoning:
  connectors:
    prometheus:
      baseUrl: "http://localhost"

thorasSlmAgent:
  enabled: false
  serviceAccount:
    name: thoras-slm-api
  podAnnotations: {}
  labels: {}
  containerPort: 11434
  port: 8080
  limits:
    memory: 8192Mi
  requests:
    cpu: 1024m
    memory: 4096Mi

# K8s client max queries per second
queriesPerSecond: "50"

# nodeSelector is used to assign components to specific nodes
nodeSelector: {}

tolerations: []
